---
title: "Nominal house prices data in Luxembourg - Data cleaning"
author: "Jake Tufts"
date: "`r Sys.Date()`"
---

<!--
Chunks with the keyword 'development' are only used when developing.
Since we need the `{testthat}` library for writing unit tests,
we load it in this development chunk. We will learn more about
unit tests in the next chapter.
-->

```{r development, include=FALSE}
library(testthat)
library(assertthat)
```


```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(janitor)
library(purrr)
library(readxl)
library(rvest)
library(stringr)
library(tidyr)
```



## Downloading the data
This data is downloaded from the Luxembourguish [Open Data
Portal](https://data.public.lu/fr/datasets/prix-annonces-des-logements-par-commune/)
(the data set called *Série rétrospective des prix
annoncés des maisons par commune, de 2010 à 2021*), 
and the original data is from the **"Observatoire de
l'habitat"**. This data contains prices for houses sold 
since 2010 for each luxembourguish commune. 

The function below uses the permanent URL from the Open Data 
Portal to access the data, but I have also rehosted the data, 
and use my link to download the data (for archival purposes):

```{r function-get_raw_data}
#' get_raw_data Gets raw nominal house price data from LU Open Data Portal
#'
#' @param url_git_remote Optional: Persistent url to git remote repo
#' @param url_git_data Optional: Persistent url to git data in repo
#' @importFrom readxl excel_sheets read_excel
#' @importFrom utils download.file
#' @importFrom dplyr mutate rename select %>%
#' @importFrom stringr str_trim
#' @importFrom janitor clean_names
#' @importFrom purrr map_dfr
#' @importFrom rlang .data
#' @return A data frame
#' @export
get_raw_data <- function(
    url_git_remote = "https://github.com/b-rodrigues/rap4all/",
    url_git_data = "raw/master/datasets/vente-maison-2010-2021.xlsx"){

  raw_data <- tempfile(fileext = ".xlsx")

  download.file(paste0(url_git_remote,url_git_data),
                raw_data,
                mode = "wb") # for compatibility with Windows

  sheets <- excel_sheets(raw_data)

  read_clean <- function(..., sheet){
    read_excel(..., sheet = sheet) %>%
      mutate(year = sheet)
  }

  raw_data <- map_dfr(sheets,
                      ~read_clean(raw_data,
                                  skip = 10,
                                  sheet = .)) %>%
    clean_names()

  raw_data %>%
    rename(locality = "commune",
           n_offers = "nombre_doffres",
           average_price_nominal_euros = "prix_moyen_annonce_en_courant",
           average_price_m2_nominal_euros = "prix_moyen_annonce_au_m2_en_courant"
           ) %>%
    mutate(locality = str_trim(.data$locality)) %>%
    select("year", "locality", "n_offers", starts_with("average"))

}

```


```{r}

raw_data <- get_raw_data(url_git_remote = "https://github.com/b-rodrigues/rap4all/",
                         url_git_data = "raw/master/datasets/vente-maison-2010-2021.xlsx")
```


We need clean the data: "Luxembourg" is "Luxembourg-ville" in 2010 and 2011,
then "Luxembourg". "Pétange" is also spelt non-consistently, and we also need
to convert columns to the right type. We also directly remove rows where the
locality contains information on the "Source":

```{r function-clean_raw_data}
#' clean_raw_data Cleans the raw data
#'
#' @param raw_data The raw data to clean (output of get_raw_data)
#' @details Removes uneeded rows, renames localities to make their names consistent across years and converts columns with prices to numeric columns
#' @importFrom dplyr mutate filter across starts_with
#' @importFrom rlang .data
#' @return A data frame
#' @export
clean_raw_data <- function(raw_data){
  
  suppressWarnings({
    raw_data |>
      mutate(locality = ifelse(grepl("Luxembourg-Ville", .data$locality),
                               "Luxembourg",
                               .data$locality),
             locality = ifelse(grepl("P.tange", .data$locality),
                               "P\u00E9tange",
                               .data$locality)
             ) |>
      filter(!grepl("Source", .data$locality)) |>
      mutate(across(starts_with("average"), as.numeric))
  })
  
}
```

```{r}
flat_data <- clean_raw_data(raw_data)
```


We now need to make sure that we got all the communes/localities 
in there. There were mergers in 2011, 2015 and 2018. So we need 
to account for these localities.

We’re now scraping data from Wikipedia of former Luxembourguish communes:

```{r function-get_former_communes}
#' get_former_communes Downloads list of former communes from Wikipedia
#'
#' @param url Optional: Persistent url to the data
#' @param min_year Minimum year to consider. Defaults to 2009 because price data starts in 2010
#' @param table_position Optional: Scraping returns a list of tables, so users need to specify the correct table. Defaults to 3, the position of the table as of writing.
#' @importFrom rvest read_html html_table
#' @importFrom dplyr filter
#' @importFrom purrr pluck
#' @importFrom janitor clean_names
#' @importFrom rlang .data
#' @return A data frame
#' @export

get_former_communes <- function(
            url = "https://w.wiki/_wFe7",
            min_year = 2009,
            table_position = 3
            ){

  read_html(url) |>
    html_table() |>
    pluck(table_position) |>
    clean_names() |>
    filter(.data$year_dissolved > min_year)
}

```

```{r}
former_communes <- get_former_communes()
```

We can scrape current communes:

```{r function-get_current_communes}
#' get_current_communes Downloads list of current communes from Wikipedia
#' 
#' @param url Optional: Persistent url to the data
#' @param table_position Optional: Scraping returns a list of tables, so users need to specify the correct table. Defaults to 2, the position of the table as of writing.
#' @importFrom rvest read_html html_table
#' @importFrom dplyr filter
#' @importFrom purrr pluck
#' @importFrom janitor clean_names
#' @return A data frame
#' @export
get_current_communes <- function(
    url = "https://w.wiki/6nPu",
    table_position = 2
    ){
  
  read_html(url) |>
    html_table() |>
    pluck(table_position) |>
    clean_names()
}

```

```{r}
current_communes <- get_current_communes()
```


Let’s now create a list of all communes:

```{r function-get_test_communes}
#' get_test_communes Creates list of communes that should be in the data
#'
#' @param former_communes Former communes df as returned by get_former_communes()
#' @param current_communes Current communes df as returned by get_current_communes()
#' @return A data frame
#' @export
get_test_communes <- function(former_communes, current_communes){

  communes <- unique(c(former_communes$name, current_communes$commune))
  # we need to rename some communes

  # Different spelling of these communes between wikipedia and the data

  communes[which(communes == "Clemency")] <- "Cl\u00E9mency"
  communes[which(communes == "Redange")] <- "Redange-sur-Attert"
  communes[which(communes == "Erpeldange-sur-S\u00FBre")] <- "Erpeldange"
  communes[which(communes == "Luxembourg-City")] <- "Luxembourg"
  communes[which(communes == 'K\u00E4erjeng')] <- "Kaerjeng"
  communes[which(communes == "Petange")] <- "P\u00E9tange"

  communes
}

```


```{r}
former_communes <- get_former_communes()
current_communes <- get_current_communes()

communes <- get_test_communes(former_communes, current_communes)
```


Let’s test to see if all the communes from our dataset are represented.

```{r tests-clean_flat_data}
# We now need to check if we have them all in the data.
# The test needs to be self-contained, hence
# why we need to redefine the required variables:

former_communes <- get_former_communes()

current_communes <- get_current_communes()

communes <- get_test_communes(
  former_communes,
  current_communes
)

raw_data <- get_raw_data(url_git_remote = "https://is.gd/1vvBAc", url_git_data = "")

flat_data <- clean_raw_data(raw_data)

testthat::test_that("Check if all communes are accounted for", {
  
  expect_true(
    all(communes %in% unique(flat_data$locality))
    )
  
})
```

If the above code doesn’t show any communes, then this means that we are 
accounting for every commune.


Let’s keep the national average in another dataset:

```{r function-make_country_level_data}
#' make_country_level_data Makes the final data at country level
#'
#' @param flat_data Flat data df as returned by clean_flat_data()
#' @importFrom dplyr filter select mutate full_join everything
#' @importFrom rlang .data
#' @return A data frame
#' @export
make_country_level_data <- function(flat_data){
  country_level <- flat_data |>
    filter(grepl("nationale", .data$locality)) |>
    select(-"n_offers")

  offers_country <- flat_data |>
    filter(grepl("Total d.offres", .data$locality)) |>
    select("year", "n_offers")

  full_join(country_level, offers_country) |>
    select("year", "locality", "n_offers", everything()) |>
    mutate(locality = "Grand-Duchy of Luxembourg")

}

```

```{r tests-make_country_level_data}
testthat::test_that("make_country_level_data creates a valid country-level data frame", {
  
  # Create sample flat data for testing
  flat_data <- data.frame(
    locality = c("nationale", "Commune_A", "Total d.offres", "Commune_B"),
    year = c(2010, 2011, 2010, 2011),
    n_offers = c(100, 120, 200, 220)
    # Add other columns as needed
  )
  
  # Call the function with sample data
  result <- make_country_level_data(flat_data)
  
  # Assert that the result is a data frame
  testthat::expect_is(result, "data.frame")
  
  # Assert that the result contains the expected columns
  testthat::expect_true("year" %in% colnames(result))
  testthat::expect_true("locality" %in% colnames(result))
  testthat::expect_true("n_offers" %in% colnames(result))
  
  # Assert that the "locality" column is set to "Grand-Duchy of Luxembourg"
  testthat::expect_equal(unique(result$locality), "Grand-Duchy of Luxembourg")
  
  # Add more assertions as needed to validate the data transformation
})

```

```{r}
country_level_data <- make_country_level_data(flat_data)
```


We can finish cleaning the commune data:

```{r function-make_commune_level_data}
#' make_commune_level_data Makes the final data at commune level
#'
#' @param flat_data Flat data df as returned by clean_flat_data()
#' @importFrom dplyr filter
#' @importFrom rlang .data
#' @return A data frame
#' @export
make_commune_level_data <- function(flat_data){
  flat_data |> 
    filter(!grepl("nationale|offres", .data$locality),
           !is.na(.data$locality))
}
```

```{r tests-make_commune_level_data}
testthat::test_that("make_commune_level_data filters out unwanted values and NAs", {
  
  # Create sample flat data for testing
  flat_data <- data.frame(
    locality = c("Commune_A", "nationale", "Commune_B", NA, "offres", "Commune_C")
  )
  
  # Call the function with sample data
  result <- make_commune_level_data(flat_data)
  
  # Assert that the result is a data frame
  testthat::expect_is(result, "data.frame")
  
  # Assert that the result does not contain unwanted values or NAs
  testthat::expect_false(any(grepl("nationale|offres", result$locality)))
  testthat::expect_true(all(!is.na(result$locality)))
})
```


```{r}
commune_level_data <- make_commune_level_data(flat_data)
```


We now save the dataset in a folder for further analysis (keep chunk option to
`eval = FALSE` to avoid running it when knitting):

```{r, eval = FALSE}
write.csv(commune_level_data,
          "datasets/house_prices_commune_level_data.csv",
          row.names = FALSE)
write.csv(country_level_data,
          "datasets/house_prices_country_level_data.csv",
          row.names = FALSE)
```

## Functions used for analysis

Compute the Laspeyeres index:

```{r function-get_laspeyeres_index}
#' get_laspeyeres_index Calculates the Laspeyeres index for each commune with 2010 as the reference year
#'
#' @param dataset Flat data df as returned by clean_flat_data()
#' @param start_year Optional: Minimal year to consider. Defaults to 2009 because price data starts in 2010
#' @importFrom dplyr group_by ungroup mutate
#' @importFrom rlang quo
#' @importFrom tidyr fill
#' @importFrom rlang .data
#' @return The input dataset with added columns: p0, p0_m2, pl and pl_m2. p0 are prices at year 0 (2010), and pl are the index.
#' @export
get_laspeyeres_index <- function(dataset, start_year = "2010"){
  
  which_dataset <- deparse(substitute(dataset))
  
  # Assertive programming
  stopifnot("dataset must be one of `commune_level_data`
           or `country_level_data`" =
            (which_dataset %in% c(
               "commune_level_data",
               "country_level_data")))
  
  group_var <- if(grepl("commune", which_dataset)){
               quo(.data$locality)
             } else {
               NULL
             }
  dataset |>
    group_by(!!group_var) |>
    mutate(p0 = ifelse(.data$year == start_year, .data$average_price_nominal_euros, NA)) |>
    fill("p0", .direction = "down") |>
    mutate(p0_m2 = ifelse(.data$year == start_year, .data$average_price_m2_nominal_euros, 
  NA)) |>
    fill("p0_m2", .direction = "down") |>
    ungroup() |>
    mutate(pl = .data$average_price_nominal_euros/.data$p0*100,
           pl_m2 = .data$average_price_m2_nominal_euros/.data$p0_m2*100)
}
```


```{r tests-get_laspeyeres}

# Basic unit tests of providing wrong dataset
testthat::test_that("Wrong data", {

  testthat::expect_error(
    get_laspeyeres_index(mtcars),
    regexp = "dataset must be one of"
  )

})

testthat::test_that("Empty data", {

  testthat::expect_error(
  # this subsetting results in an empty dataset
    get_laspeyeres_index(subset(mtcars, am == 2))
  )

})

# More complex unit tests checking that input = expected results of function
testthat::test_that("get_laspeyeres() produces correct results", {

  input_df <- expand.grid(
    list("year" = c(2010, 2011),
         "locality" = c("Bascharage", "Luxembourg"))
  )

  input_df$n_offers <- c(123, 101, 1230, 1010)
  input_df$average_price_nominal_euros <- c(234, 345, 560, 670)
  input_df$average_price_m2_nominal_euros <- c(23, 34, 56, 67)

  expected_df <- input_df

  # p0 should be always equal to the value in the first year
  expected_df$p0 <- c(234, 234, 560, 560)
  expected_df$p0_m2 <- c(23, 23, 56, 56)

  # pl should be equal to the price divided by p0
  expected_df$pl <- expected_df$average_price_nominal_euros / expected_df$p0 * 100
  expected_df$pl_m2 <- expected_df$average_price_m2_nominal_euros / expected_df$p0_m2 * 100

  # rename data to make assertion pass
  commune_level_data <- input_df

  testthat::expect_equivalent(
    expected_df, get_laspeyeres_index(commune_level_data)
  )

})
```


```{r examples-get_laspeyeres, eval = FALSE}
#' \dontrun{
#' country_level_data_laspeyeres <- get_laspeyeres_index(country_level_data)
#' commune_level_data_laspeyeres <- get_laspeyeres(commune_level_data)
#' } 
```

Plot the prices of the communes

```{r function-make_plot}
#' make_plot Creates plot of Country and Commune Laspeyeres index prices (price adjusted) over time
#'
#' @param country_level_data The country level data frame.
#' @param commune_level_data The commune level data frame.
#' @param commune The commune to plot.
#' @importFrom dplyr filter bind_rows
#' @importFrom ggplot2 ggplot geom_line aes
#' @return A ggplot
#' @export

make_plot <- function(country_level_data, commune_level_data, commune){

  commune_data <- commune_level_data |>
    filter(.data$locality == commune)

  data_to_plot <- bind_rows(
    country_level_data,
    commune_data
  )

  ggplot(data_to_plot) +
    geom_line(aes(y = .data$pl_m2,
                  x = .data$year,
                  group = .data$locality,
                  colour = .data$locality))
}
```


```{r tests-make_plot}

test_that("make_plot creates a ggplot object", {
  # Create sample data for testing
  country_data <- data.frame(
    locality = c("Country_A", "Country_A"),
    year = c(2010, 2011),
    pl_m2 = c(100, 120)
  )
  
  commune_data <- data.frame(
    locality = c("Commune_X", "Commune_X"),
    year = c(2010, 2011),
    pl_m2 = c(110, 130)
  )
  
  # Call the function with sample data
  plot <- make_plot(country_data, commune_data, "Commune_X")
  
  # Assert that the result is a ggplot object
  testthat::expect_true(ggplot2::is.ggplot(plot))
})


```


```{r examples-make_plot, eval = FALSE}
#' \dontrun{
#' country_level_data_laspeyeres <- get_laspeyeres_index(country_level_data)
#' commune_level_data_laspeyeres <- get_laspeyeres_index(commune_level_data)
#' make_plot(country_level_data_laspeyeres, commune_level_data_laspeyeres, "Luxembourg")
#' }
```

